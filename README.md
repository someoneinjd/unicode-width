# unicode-width

A C++17 header-only library for calculating the display width of characters according to [Unicode Standard Annex #11](www.unicode.org/reports/tr11/) rules.

> **Note**: the header file is generated by `scripts/generate.py`, which is modified from [unicode-rs/unicode-width](https://github.com/unicode-rs/unicode-width/blob/master/scripts/unicode.py)

## API Reference

```cpp
// char_type = char/char16_t/cha32_t/wchar_t/char8_t (C++20)

// calculate the display width of a single character.
std::optional<size_t> unicode_width::width(char_type ch, bool is_cjk = true);

// calculate the display width of a string.
std::optional<size_t> unicode_width::width(const std::basic_string<char_type> &str, bool is_cjk = true);
std::optional<size_t> unicode_width::width(const std::basic_string_view<char_type> str, bool is_cjk = true);
std::optional<size_t> unicode_width::width(const char_type (&str)[N], bool is_cjk = true);
std::optional<size_t> unicode_width::width(const char_type *str, size_t len, boo is_cjk = true);
```

`width` returns `std::nullopt` if the character is non-printable or the string contains non-printable characters. 

If `is_cjk == true`, ambiguous width characters are treated as double width; otherwise, they're treated as single width.

Note: `char`-based strings are processed using UTF-8. And for `wchar_t`-based strings, there are two cases:

* `sizeof(wchar_t) == 2`: strings are processed using UTF-16 LE.
* `size_t(wchar_t) == 4`: strings are processed using UTF-32.

Incorrectly encoded strings will result in undefined behavior.
